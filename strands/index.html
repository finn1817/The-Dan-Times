<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Strands - The Daily Clone</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Karnak+Pro:wght@700&family=Franklin+Gothic:wght@500;700&display=swap');

        :root {
            --bg-color: #fdfbf7;
            --grid-gap: 12px;
            --letter-size: 44px;
            --theme-blue: #cce5ff;
            --theme-blue-text: #1c3a5e;
            --spangram-yellow: #fcf4db;
            --spangram-yellow-text: #b59f3b;
            --selection-color: #dcdcdc; 
            --font-serif: 'Karnak Pro', serif;
            --font-sans: 'Franklin Gothic', sans-serif;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            color: #121212;
            overflow: hidden;
        }

        header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ccc;
            background: white;
            z-index: 10;
        }

        h1 { font-family: var(--font-serif); font-size: 1.8rem; margin: 0; }
        .date { font-size: 0.8rem; font-weight: bold; color: #333; }

        #game-info { text-align: center; padding: 20px; max-width: 400px; }
        .theme-label { font-size: 0.75rem; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; color: #666; }
        .theme-text { font-size: 1.2rem; font-weight: bold; margin: 5px 0 15px 0; }
        
        .status-bar { display: flex; justify-content: space-between; font-size: 0.9rem; color: #555; margin-bottom: 10px; width: 100%; padding: 0 20px; }

        #game-container { position: relative; margin: 0 auto; padding: 10px; }

        #grid {
            display: grid;
            grid-template-columns: repeat(6, var(--letter-size));
            grid-template-rows: repeat(8, var(--letter-size));
            gap: var(--grid-gap);
            position: relative;
            z-index: 2;
        }

        .cell {
            width: var(--letter-size);
            height: var(--letter-size);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 50%;
            transition: transform 0.1s;
            background-color: transparent;
        }

        /* SVG Line Layer - Must be pointer-events: none to allow swiping */
        #line-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1; 
            overflow: visible;
        }

        .connector-line {
            fill: none;
            stroke-width: 12; 
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 0.8;
            transition: stroke 0.3s;
        }

        .cell.selected { background-color: var(--selection-color); transform: scale(1.1); }
        .cell.found-word { background-color: var(--theme-blue); color: var(--theme-blue-text); animation: pop 0.3s; }
        .cell.found-spangram { background-color: var(--spangram-yellow); color: var(--spangram-yellow-text); animation: pop 0.3s; }

        @keyframes pop { 50% { transform: scale(1.2); } }

        #controls { margin-top: 20px; display: flex; gap: 15px; }
        button {
            padding: 12px 24px; border-radius: 30px; border: 1px solid #ccc;
            background: white; font-weight: bold; cursor: pointer;
        }
        button:hover { background: #f0f0f0; }

        #modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.98);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200;
        }
    </style>
</head>
<body>

<header>
    <div style="font-weight:bold; font-size:1.2rem;">☰</div>
    <h1>Strands</h1>
    <div class="date">Daily Clone</div>
</header>

<div id="game-info">
    <div class="theme-label">Today's Theme</div>
    <div class="theme-text" id="theme-text">Loading...</div>
    <div class="status-bar">
        <span>Found: <span id="count-found">0</span>/<span id="count-total">0</span></span>
        <span>Spangram: <span id="span-status">❌</span></span>
    </div>
</div>

<div id="game-container">
    <svg id="line-layer">
        <g id="found-lines"></g> 
        <polyline id="drag-polyline" class="connector-line" style="stroke: var(--selection-color);" points=""></polyline>
    </svg>
    <div id="grid"></div>
</div>

<div id="controls">
    <button onclick="hint()">Hint</button>
    <button onclick="location.reload()">New Puzzle</button>
</div>

<div id="modal">
    <h2 style="font-family: var(--font-serif); font-size: 2rem;">Puzzle Solved!</h2>
    <div id="word-list" style="text-align:center; line-height:1.6; font-size:1.2rem;"></div>
    <button onclick="location.reload()" style="background:#000; color:#fff; border:none; padding:15px 30px; border-radius:30px; margin-top:20px; cursor:pointer;">Play Next Level</button>
</div>

<script>
    const COLS = 6;
    const ROWS = 8;
    
    let gridLetters = "";
    let wordMap = {};
    let foundWords = new Set();
    let currentPath = [];
    let isDragging = false;
    let totalWords = 0;
    let currentLevelData = null;

    const gridEl = document.getElementById('grid');
    const polyline = document.getElementById('drag-polyline');
    const foundLinesGroup = document.getElementById('found-lines');

    // 1. Init
    async function initGame() {
        const groupId = Math.floor(Math.random() * 5) + 1;
        console.log(`Loading Group ${groupId}`);
        try {
            const response = await fetch(`groups/group_${groupId}.txt`);
            if (!response.ok) throw new Error("File missing");
            const data = await response.json();
            setupLevel(data);
        } catch (e) {
            console.error(e);
            document.getElementById('theme-text').innerText = "Error: Check group files";
        }
    }

    function setupLevel(data) {
        currentLevelData = data;
        document.getElementById('theme-text').innerText = data.theme;
        
        // Build a fresh scrambled layout from the word list
        let wordsList = null;
        if (Array.isArray(data.words) && data.words.length > 0) {
            wordsList = data.words.slice();
        } else if (data.solutions) {
            wordsList = Object.keys(data.solutions);
        } else {
            wordsList = [];
        }

        const generated = generateGridFromWords(wordsList);
        gridLetters = generated.grid;
        wordMap = generated.solutions;
        totalWords = Object.keys(wordMap).length;
        document.getElementById('count-total').innerText = totalWords;
        
        gridEl.innerHTML = '';
        for (let i = 0; i < gridLetters.length; i++) {
            const d = document.createElement('div');
            d.className = 'cell';
            d.innerText = gridLetters[i];
            d.dataset.idx = i;
            gridEl.appendChild(d);
        }

        // 2. Interaction
        document.addEventListener('pointerdown', startDrag);
        document.addEventListener('pointermove', handleMove);
        document.addEventListener('pointerup', endDrag);
    }

    function startDrag(e) {
        const cell = e.target.closest('.cell');
        if (!cell || foundWords.size === totalWords) return;
        
        isDragging = true;
        const idx = parseInt(cell.dataset.idx);

        if (!isCellFound(idx)) {
            currentPath = [idx];
            updateVisuals();
        }
    }

    function handleMove(e) {
        if (!isDragging) return;
        const target = document.elementFromPoint(e.clientX, e.clientY);
        if (!target) return;
        const cell = target.closest('.cell');
        if (!cell) return;

        const idx = parseInt(cell.dataset.idx);
        const lastIdx = currentPath[currentPath.length - 1];
        if (lastIdx === undefined) return;

        if (currentPath.length > 1 && idx === currentPath[currentPath.length - 2]) {
            currentPath.pop();
            updateVisuals();
            return;
        }

        if (idx !== lastIdx && !currentPath.includes(idx) && isAdjacent(lastIdx, idx) && !isCellFound(idx)) {
            currentPath.push(idx);
            updateVisuals();
        }
    }

    function endDrag(e) {
        if (!isDragging) return;
        isDragging = false;
        
        const formedWord = currentPath.map(i => gridLetters[i]).join("");
        const reversedWord = formedWord.split('').reverse().join('');
        
        let validKey = null;
        if (wordMap[formedWord]) validKey = formedWord;
        else if (wordMap[reversedWord]) validKey = reversedWord;

        if (validKey && !foundWords.has(validKey)) {
            foundWords.add(validKey);
            finalizeWord(validKey);
        }

        currentPath = [];
        updateVisuals();
    }

    // 3. Helpers
    function isAdjacent(i1, i2) {
        const r1 = Math.floor(i1 / COLS);
        const c1 = i1 % COLS;
        const r2 = Math.floor(i2 / COLS);
        const c2 = i2 % COLS;
        return (Math.abs(r1 - r2) <= 1 && Math.abs(c1 - c2) <= 1) && !(r1===r2 && c1===c2);
    }

    function isCellFound(idx) {
        for (let w of foundWords) if (wordMap[w].includes(idx)) return true;
        return false;
    }

    // Randomize and generate a valid, fully-used board from words
    function generateGridFromWords(words) {
        const targetCells = COLS * ROWS;
        const totalLetters = words.reduce((sum, w) => sum + w.length, 0);

        // If counts don't match exactly, fall back to simple row layout
        if (totalLetters !== targetCells) {
            return simpleRowLayout(words, targetCells);
        }

        for (let attempt = 0; attempt < 40; attempt++) {
            const used = new Set();
            const tempSolutions = {};
            const gridArr = new Array(targetCells);

            const shuffledWords = shuffleArray(words.slice());
            let ok = true;

            for (const word of shuffledWords) {
                const path = findPathForWord(word.length, used);
                if (!path) { ok = false; break; }

                const finalPath = Math.random() < 0.5 ? path.slice().reverse() : path;
                tempSolutions[word] = finalPath;

                for (let i = 0; i < finalPath.length; i++) {
                    const idx = finalPath[i];
                    used.add(idx);
                    gridArr[idx] = word[i];
                }
            }

            if (ok) {
                const orderedSolutions = {};
                words.forEach(w => { orderedSolutions[w] = tempSolutions[w]; });
                return { grid: gridArr.join(''), solutions: orderedSolutions };
            }
        }

        // As a safety net, still produce a playable (but row-like) layout
        return simpleRowLayout(words, targetCells);
    }

    function simpleRowLayout(words, targetCells) {
        let grid = "";
        const solutions = {};
        let idx = 0;
        for (const word of words) {
            const indices = [];
            for (const ch of word) {
                if (idx >= targetCells) break;
                grid += ch;
                indices.push(idx++);
            }
            solutions[word] = indices;
        }
        while (grid.length < targetCells) grid += 'X';
        return { grid, solutions };
    }

    function updateVisuals() {
        document.querySelectorAll('.cell').forEach(c => {
            const idx = parseInt(c.dataset.idx);
            if (currentPath.includes(idx)) c.classList.add('selected');
            else c.classList.remove('selected');
        });
        if (currentPath.length < 2) {
            polyline.setAttribute('points', '');
            return;
        }
        const points = currentPath.map(idx => getCenterCoord(idx)).join(" ");
        polyline.setAttribute('points', points);
    }

    function getCenterCoord(idx) {
        const cell = document.querySelector(`.cell[data-idx="${idx}"]`);
        if (!cell) return "0,0";
        const rect = cell.getBoundingClientRect();
        const containerRect = document.getElementById('game-container').getBoundingClientRect();
        return `${rect.left + rect.width/2 - containerRect.left},${rect.top + rect.height/2 - containerRect.top}`;
    }

    function getNeighbors(idx) {
        const neighbors = [];
        const r = Math.floor(idx / COLS);
        const c = idx % COLS;
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                    neighbors.push(nr * COLS + nc);
                }
            }
        }
        return neighbors;
    }

    function findPathForWord(length, used) {
        const allIndices = [];
        for (let i = 0; i < COLS * ROWS; i++) {
            if (!used.has(i)) allIndices.push(i);
        }
        const starts = shuffleArray(allIndices);

        for (const start of starts) {
            const path = [start];
            const visited = new Set([start]);
            if (dfsExtend(path, visited, length, used)) return path;
        }
        return null;
    }

    function dfsExtend(path, visited, targetLen, used) {
        if (path.length === targetLen) return true;
        const last = path[path.length - 1];
        let neighbors = getNeighbors(last).filter(n => !used.has(n) && !visited.has(n));
        neighbors = shuffleArray(neighbors);

        for (const n of neighbors) {
            visited.add(n);
            path.push(n);
            if (dfsExtend(path, visited, targetLen, used)) return true;
            path.pop();
            visited.delete(n);
        }
        return false;
    }

    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    }

    function finalizeWord(word) {
        const indices = wordMap[word];
        const isSpangram = (word === currentLevelData.spangram);
        const color = isSpangram ? '#b59f3b' : '#1c3a5e';
        const cellClass = isSpangram ? 'found-spangram' : 'found-word';

        indices.forEach(idx => {
            const c = document.querySelector(`.cell[data-idx="${idx}"]`);
            if(c) {
                c.classList.remove('selected');
                c.classList.add(cellClass);
            }
        });

        // Use the indices from the file to draw the perfect line
        const points = indices.map(idx => getCenterCoord(idx)).join(" ");
        const newLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
        newLine.setAttribute('points', points);
        newLine.setAttribute('class', 'connector-line');
        newLine.style.stroke = color;
        newLine.style.opacity = 0.4;
        foundLinesGroup.appendChild(newLine);

        document.getElementById('count-found').innerText = foundWords.size;
        if(isSpangram) {
            document.getElementById('span-status').innerText = word;
            document.getElementById('span-status').style.color = "#b59f3b";
            document.getElementById('span-status').style.fontWeight = "bold";
        }
        
        if (foundWords.size === totalWords) {
            setTimeout(() => {
                let html = "";
                if(currentLevelData.spangram) html += `<div style="color:#b59f3b; font-weight:bold; margin-bottom:15px;">${currentLevelData.spangram}</div>`;
                foundWords.forEach(w => { if(w!==currentLevelData.spangram) html += `<div>${w}</div>`; });
                document.getElementById('word-list').innerHTML = html;
                document.getElementById('modal').style.display = 'flex';
            }, 500);
        }
    }

    function hint() {
        const all = Object.keys(wordMap);
        const missing = all.find(w => !foundWords.has(w));
        if (missing) {
            const idx = wordMap[missing][0];
            const c = document.querySelector(`.cell[data-idx="${idx}"]`);
            c.style.backgroundColor = "pink";
            setTimeout(() => c.style.backgroundColor = "", 1000);
        }
    }

    initGame();
</script>
</body>
</html>