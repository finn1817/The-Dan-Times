<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pips - NYT Authentic Style</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Karnak+Pro:wght@700&family=Franklin+Gothic:wght@500;700&display=swap');

        :root {
            --bg-color: #ffffff;
            --board-bg-beige: #e6dace; /* The distinct beige background of the board track */
            --slot-empty: rgba(0,0,0,0.05);
            --domino-white: #fdfdfd;
            --pip-black: #1a1a1a;
            
            /* Region Colors (from your image) */
            --reg-purple: #a881af;
            --reg-pink: #ea9ab2;
            --reg-teal: #8fb6b5;
            --reg-orange: #eeb786;
            --reg-blue: #8fa1b3;
            --reg-blue-tag: #1c3a5e;
            
            /* UI Colors */
            --btn-black: #121212;
            --shadow-subtle: 0 4px 12px rgba(0,0,0,0.15);
        }

        body {
            font-family: 'Franklin Gothic', sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            color: #333;
        }

        h1 {
            font-family: 'Karnak Pro', serif;
            font-size: 2.5rem;
            margin: 20px 0 5px 0;
            letter-spacing: -0.5px;
        }
        .subtitle {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 30px;
        }

        /* --- THE BOARD AREA --- */
        #game-area {
            position: relative;
            width: 360px;
            height: 480px; /* Adjusted for the specific shape */
            margin-bottom: 20px;
            /* Centering content */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The Grid: We use absolute positioning for cells to handle irregular shapes perfectly */
        .board-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to slots */
        }

        .cell-bg {
            position: absolute;
            width: 76px;
            height: 76px;
            border-radius: 8px;
            /* The beige track color */
            background-color: var(--board-bg-beige); 
            z-index: 0;
        }

        /* Colored Regions (The dashed overlays) */
        .region {
            position: absolute;
            border: 2px dashed;
            z-index: 1;
            pointer-events: none;
            border-radius: 12px;
            opacity: 0.9;
        }
        
        /* Region specific styles */
        .reg-purple { background-color: var(--reg-purple); border-color: #7a5080; }
        .reg-pink   { background-color: var(--reg-pink);   border-color: #c96e85; }
        .reg-teal   { background-color: var(--reg-teal);   border-color: #5f8080; }
        .reg-orange { background-color: var(--reg-orange); border-color: #b88250; }
        .reg-blue   { background-color: var(--reg-blue);   border-color: #1c3a5e; }

        /* The Slots (Where dominoes actually drop) */
        #slots-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5; /* Above regions */
        }

        .slot {
            position: absolute;
            border-radius: 10px;
            /* visual debugging: border: 1px solid red; */
            transition: transform 0.2s;
            cursor: pointer;
        }
        /* Vertical Slot */
        .slot[data-orient="v"] { width: 72px; height: 154px; }
        /* Horizontal Slot */
        .slot[data-orient="h"] { width: 154px; height: 72px; }

        .slot.hovered {
            background-color: rgba(0,0,0,0.1);
            transform: scale(1.02);
        }

        /* --- TAGS (The visual rules) --- */
        .tag {
            position: absolute;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: 800;
            font-size: 1.1rem;
            filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.3));
        }
        
        /* Custom Shapes for Tags */
        .tag-diamond {
            width: 40px; height: 40px;
            transform: rotate(45deg);
            border-radius: 6px;
        }
        .tag-diamond span { transform: rotate(-45deg); }

        .tag-round {
            width: 44px; height: 34px;
            border-radius: 12px;
        }

        .tag-pentagon {
            width: 44px; height: 44px;
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
            display: flex; justify-content: center; align-items: center; padding-top: 5px;
        }

        /* --- DOMINOES --- */
        .domino {
            width: 70px;
            height: 150px;
            background-color: var(--domino-white);
            border-radius: 12px;
            box-shadow: 0 4px 0 #ccc, 0 5px 10px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            border: 1px solid #ddd;
            cursor: grab;
            transition: transform 0.1s;
            position: relative;
        }
        .domino:active { cursor: grabbing; transform: scale(1.05); box-shadow: 0 2px 0 #ccc; }
        
        .domino[data-orient="h"] {
            width: 150px; height: 70px;
            flex-direction: row;
        }

        .half {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* The dividing line */
        .domino::after {
            content: "";
            position: absolute;
            background: #e0e0e0;
        }
        .domino[data-orient="v"]::after {
            top: 50%; left: 10px; right: 10px; height: 2px;
        }
        .domino[data-orient="h"]::after {
            left: 50%; top: 10px; bottom: 10px; width: 2px;
        }

        /* Dots */
        .pip-grid {
            display: grid;
            grid-template-columns: repeat(3, 12px);
            grid-template-rows: repeat(3, 12px);
            gap: 4px;
        }
        .dot {
            background-color: var(--pip-black);
            border-radius: 50%;
            width: 100%; height: 100%;
            visibility: hidden;
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.3);
        }

        /* Dot Layouts */
        .v1 .d5 { visibility: visible; }
        .v2 .d1, .v2 .d9 { visibility: visible; }
        .v3 .d1, .v3 .d5, .v3 .d9 { visibility: visible; }
        .v4 .d1, .v4 .d3, .v4 .d7, .v4 .d9 { visibility: visible; }
        .v5 .d1, .v5 .d3, .v5 .d5, .v5 .d7, .v5 .d9 { visibility: visible; }
        .v6 .d1, .v6 .d3, .v6 .d4, .v6 .d6, .v6 .d7, .v6 .d9 { visibility: visible; }

        /* --- TRAY --- */
        #tray {
            width: 90%;
            max-width: 600px;
            background: #f4f4f4;
            border-radius: 20px;
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            min-height: 160px;
            flex-wrap: wrap;
        }

        /* --- CONTROLS --- */
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }
        .btn {
            padding: 14px 32px;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .btn-check { background-color: var(--btn-black); color: white; }
        .btn-reset { background-color: #ddd; color: #333; }
        .btn:hover { opacity: 0.85; }

        /* --- OVERLAYS --- */
        .check-mark {
            position: absolute;
            font-size: 2rem;
            color: white;
            background: #4caf50;
            border-radius: 50%;
            width: 40px; height: 40px;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .error-x {
            position: absolute;
            font-size: 2rem;
            color: white;
            background: #d93025;
            border-radius: 50%;
            width: 40px; height: 40px;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

    </style>
</head>
<body>

    <h1>PIPS</h1>
    <div class="subtitle">The Daily Clone</div>

    <div id="game-area">
        <div id="board-bg-layer" class="board-layer"></div>
        
        <div id="regions-layer" class="board-layer"></div>
        
        <div id="tags-layer" class="board-layer"></div>

        <div id="slots-layer"></div>

        <div id="feedback-layer" class="board-layer" style="z-index: 60; pointer-events: none;"></div>
    </div>

    <div id="tray"></div>

    <div id="controls">
        <button class="btn btn-reset" onclick="resetGame()">Reset</button>
        <button class="btn btn-check" onclick="checkSolution()">Check</button>
    </div>

<script>
    // --- DATA ---
    
    // Cell Size
    const CELL = 80; 
    const PAD = 4; // Gap between cells visually
    
    // The specific board shape from your image
    // Coordinates are (col, row)
    // 0,0 is top left.
    const BOARD_SHAPE = [
        {x:0, y:0}, {x:1, y:0}, {x:2, y:0}, // Row 0
        {x:0, y:1}, {x:1, y:1}, {x:2, y:1}, // Row 1
                    {x:2, y:2}, // Row 2 (Narrow neck)
        {x:0, y:3}, {x:1, y:3}, {x:2, y:3}  // Row 3 (Bottom block)
    ];

    // The Logic Regions (Colors & Rules)
    // Based on image_f20005.png
    const REGIONS = [
        {
            id: 'purple',
            colorClass: 'reg-purple',
            cells: [{x:0, y:0}], // Top Left single
            rule: { type: 'sum', val: 6 },
            tag: { type: 'diamond', color: '#8e5c9b', text: '6', pos: {x: 40, y: 50} } // Offset from cell
        },
        {
            id: 'pink',
            colorClass: 'reg-pink',
            cells: [{x:1, y:0}, {x:1, y:1}], // Vertical middle top
            rule: { type: 'equal' },
            // FIXED POS: Moved from {x:100, y:130} to {x:60, y:60} based on user feedback
            tag: { type: 'pentagon', color: '#d63384', text: '=', pos: {x: 60, y: 60} }
        },
        {
            id: 'teal',
            colorClass: 'reg-teal',
            cells: [{x:2, y:0}], // Top Right single
            rule: { type: 'gt', val: 3 }, // > 3
            tag: { type: 'round', color: '#007ca5', text: '>3', pos: {x: 40, y: 50} }
        },
        {
            id: 'orange',
            colorClass: 'reg-orange',
            cells: [{x:2, y:1}, {x:2, y:2}], // Vertical right
            rule: { type: 'sum', val: 12 },
            tag: { type: 'diamond', color: '#d95e00', text: '12', pos: {x: 50, y: 130} }
        },
        {
            id: 'blue',
            colorClass: 'reg-blue',
            cells: [{x:1, y:3}, {x:2, y:3}], // Bottom horizontal
            rule: { type: 'sum', val: 11 },
            tag: { type: 'pentagon', color: '#112e51', text: '11', pos: {x: 130, y: 50} }
        }
    ];

    // The Slots (Where dominoes fit)
    // This is the "hidden" logic of the board layout.
    // Slots connect 2 cells.
    const SLOTS = [
        { id: 's1', c1: {x:0, y:0}, c2: {x:0, y:1}, orient: 'v' }, // Left Col (Purple + Beige)
        { id: 's2', c1: {x:1, y:0}, c2: {x:1, y:1}, orient: 'v' }, // Mid Col (Pink)
        { id: 's3', c1: {x:2, y:0}, c2: {x:2, y:1}, orient: 'v' }, // Right Top (Teal + Orange Top)
        { id: 's4', c1: {x:2, y:2}, c2: {x:2, y:3}, orient: 'v' }, // Right Bot (Orange Bot + Blue Right)
        { id: 's5', c1: {x:0, y:3}, c2: {x:1, y:3}, orient: 'h' }  // Bot Left (Beige + Blue Left)
    ];

    // The Dominoes (From the screenshot)
    const DOMINOES = [
        { id: 'd1', v1: 6, v2: 6 },
        { id: 'd2', v1: 1, v2: 5 },
        { id: 'd3', v1: 6, v2: 4 },
        { id: 'd4', v1: 6, v2: 2 },
        { id: 'd5', v1: 2, v2: 0 } // Blank is 0
    ];

    // State
    let placedDominoes = {}; // slotId -> {domId, v1, v2}

    // --- RENDERERS ---

    function init() {
        renderBoardBg();
        renderRegions();
        renderSlots();
        renderTray();
    }

    function renderBoardBg() {
        const layer = document.getElementById('board-bg-layer');
        BOARD_SHAPE.forEach(cell => {
            const div = document.createElement('div');
            div.className = 'cell-bg';
            div.style.left = (cell.x * CELL + PAD) + 'px';
            div.style.top = (cell.y * CELL + PAD) + 'px';
            layer.appendChild(div);
        });
    }

    function renderRegions() {
        const regLayer = document.getElementById('regions-layer');
        const tagLayer = document.getElementById('tags-layer');
        const fbLayer = document.getElementById('feedback-layer');

        REGIONS.forEach(reg => {
            // Draw Region Box
            // We need to find bounding box of cells
            const minX = Math.min(...reg.cells.map(c=>c.x));
            const minY = Math.min(...reg.cells.map(c=>c.y));
            const maxX = Math.max(...reg.cells.map(c=>c.x));
            const maxY = Math.max(...reg.cells.map(c=>c.y));
            
            const w = (maxX - minX + 1) * CELL - 4; // -4 for visual margin
            const h = (maxY - minY + 1) * CELL - 4;

            const div = document.createElement('div');
            div.className = `region ${reg.colorClass}`;
            div.style.left = (minX * CELL + 2) + 'px';
            div.style.top = (minY * CELL + 2) + 'px';
            div.style.width = (w - 4) + 'px'; // adjust for borders
            div.style.height = (h - 4) + 'px';
            regLayer.appendChild(div);

            // Draw Tag
            if (reg.tag) {
                const tag = document.createElement('div');
                tag.className = `tag tag-${reg.tag.type}`;
                tag.style.backgroundColor = reg.tag.color;
                
                // Position relative to Region Top-Left
                tag.style.left = ((minX * CELL) + reg.tag.pos.x) + 'px';
                tag.style.top = ((minY * CELL) + reg.tag.pos.y) + 'px';
                
                const span = document.createElement('span');
                span.innerText = reg.tag.text;
                tag.appendChild(span);
                tagLayer.appendChild(tag);
                
                // Add Check/X mark placeholder near tag
                const check = document.createElement('div');
                check.className = 'check-mark';
                check.innerHTML = '✓';
                check.id = `feedback-ok-${reg.id}`;
                check.style.left = tag.style.left;
                check.style.top = tag.style.top;
                fbLayer.appendChild(check);

                const fail = document.createElement('div');
                fail.className = 'error-x';
                fail.innerHTML = '✕';
                fail.id = `feedback-fail-${reg.id}`;
                fail.style.left = tag.style.left;
                fail.style.top = tag.style.top;
                fbLayer.appendChild(fail);
            }
        });
    }

    function renderSlots() {
        const layer = document.getElementById('slots-layer');
        layer.innerHTML = '';
        SLOTS.forEach(slot => {
            const div = document.createElement('div');
            div.className = 'slot';
            div.dataset.id = slot.id;
            div.dataset.orient = slot.orient;
            
            // Calculate Top/Left based on c1 (top/left-most cell)
            div.style.left = (slot.c1.x * CELL + 4) + 'px';
            div.style.top = (slot.c1.y * CELL + 4) + 'px';

            div.addEventListener('dragover', e => e.preventDefault());
            div.addEventListener('drop', handleDrop);
            div.addEventListener('click', handleSlotClick); // Click placed domino to flip

            layer.appendChild(div);
        });
    }

    function createDominoHTML(v1, v2) {
        return `
            <div class="half v${v1}">
                <div class="pip-grid">
                    <div class="dot d1"></div><div class="dot d2"></div><div class="dot d3"></div>
                    <div class="dot d4"></div><div class="dot d5"></div><div class="dot d6"></div>
                    <div class="dot d7"></div><div class="dot d8"></div><div class="dot d9"></div>
                </div>
            </div>
            <div class="half v${v2}">
                <div class="pip-grid">
                    <div class="dot d1"></div><div class="dot d2"></div><div class="dot d3"></div>
                    <div class="dot d4"></div><div class="dot d5"></div><div class="dot d6"></div>
                    <div class="dot d7"></div><div class="dot d8"></div><div class="dot d9"></div>
                </div>
            </div>
        `;
    }

    function renderTray() {
        const tray = document.getElementById('tray');
        tray.innerHTML = '';
        DOMINOES.forEach(d => {
            // Check if already placed
            const isPlaced = Object.values(placedDominoes).some(pd => pd.domId === d.id);
            if(isPlaced) return;

            const el = document.createElement('div');
            el.className = 'domino';
            el.draggable = true;
            el.id = d.id;
            el.dataset.v1 = d.v1;
            el.dataset.v2 = d.v2;
            el.dataset.orient = 'v';
            el.innerHTML = createDominoHTML(d.v1, d.v2);
            
            el.addEventListener('dragstart', e => {
                e.dataTransfer.setData('domId', d.id);
                // Also store offset if we want precise drag... skipping for simplicity
            });
            
            // Click to rotate in tray
            el.addEventListener('click', () => {
               // Just swap visual values for tray rotation? 
               // Standard Pips doesn't usually rotate in tray, but let's allow flip
               const t = el.dataset.v1;
               el.dataset.v1 = el.dataset.v2;
               el.dataset.v2 = t;
               el.innerHTML = createDominoHTML(el.dataset.v1, el.dataset.v2);
            });

            tray.appendChild(el);
        });
    }

    // --- INTERACTION ---

    function handleDrop(e) {
        e.preventDefault();
        const slot = e.currentTarget;
        const domId = e.dataTransfer.getData('domId');
        
        // If slot occupied, return to tray (or swap - basic for now)
        if(placedDominoes[slot.dataset.id]) return;

        const domData = DOMINOES.find(d => d.id === domId);
        
        // Place it
        placedDominoes[slot.dataset.id] = {
            domId: domId,
            v1: domData.v1,
            v2: domData.v2
        };

        renderPlacedDominoes();
        renderTray();
        clearFeedback();
    }

    function handleSlotClick(e) {
        const slot = e.currentTarget;
        const slotId = slot.dataset.id;
        
        if(placedDominoes[slotId]) {
            // Flip the values
            const d = placedDominoes[slotId];
            const temp = d.v1;
            d.v1 = d.v2;
            d.v2 = temp;
            renderPlacedDominoes();
            clearFeedback();
        }
    }

    // Re-render only the placed items on the board
    function renderPlacedDominoes() {
        // Clear slots
        document.querySelectorAll('.slot').forEach(s => s.innerHTML = '');

        Object.keys(placedDominoes).forEach(slotId => {
            const pd = placedDominoes[slotId];
            const slotEl = document.querySelector(`.slot[data-id="${slotId}"]`);
            
            const domEl = document.createElement('div');
            domEl.className = 'domino';
            domEl.dataset.orient = slotEl.dataset.orient;
            // Remove drag events from placed items, handled by click to flip
            // But we want to be able to drag it AWAY later? 
            // For now, Click to Flip. Double Click to Remove?
            domEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                delete placedDominoes[slotId];
                renderPlacedDominoes();
                renderTray();
                clearFeedback();
            });

            domEl.innerHTML = createDominoHTML(pd.v1, pd.v2);
            slotEl.appendChild(domEl);
        });
    }

    function resetGame() {
        placedDominoes = {};
        renderPlacedDominoes();
        renderTray();
        clearFeedback();
    }

    function clearFeedback() {
        document.querySelectorAll('.check-mark, .error-x').forEach(el => el.style.display = 'none');
    }

    // --- LOGIC CHECKER ---

    function checkSolution() {
        clearFeedback();
        
        // 1. Build a map of Grid Coordinates to Values
        // Initialize with null
        const gridMap = {}; // "x,y" -> value

        SLOTS.forEach(slot => {
            if(placedDominoes[slot.id]) {
                const p = placedDominoes[slot.id];
                // Map v1 to c1, v2 to c2
                gridMap[`${slot.c1.x},${slot.c1.y}`] = p.v1;
                gridMap[`${slot.c2.x},${slot.c2.y}`] = p.v2;
            }
        });

        // 2. Validate Regions
        let allPass = true;
        let isFull = Object.keys(placedDominoes).length === SLOTS.length;

        if(!isFull) {
            alert("Place all dominoes first!");
            return;
        }

        REGIONS.forEach(reg => {
            // Get values for this region
            const values = reg.cells.map(c => gridMap[`${c.x},${c.y}`]);
            
            // If any value is undefined, fail hard
            if(values.includes(undefined)) {
                allPass = false; return;
            }

            let passed = false;
            if(reg.rule.type === 'sum') {
                const sum = values.reduce((a,b)=>a+b, 0);
                passed = (sum === reg.rule.val);
            } 
            else if(reg.rule.type === 'equal') {
                passed = values.every(v => v === values[0]);
            }
            else if(reg.rule.type === 'gt') {
                // Assuming all cells in region must be > X
                passed = values.every(v => v > reg.rule.val);
            }

            // Show UI Feedback
            if(passed) {
                document.getElementById(`feedback-ok-${reg.id}`).style.display = 'flex';
            } else {
                document.getElementById(`feedback-fail-${reg.id}`).style.display = 'flex';
                allPass = false;
            }
        });

        if(allPass) {
            setTimeout(() => alert("Puzzle Solved! Great job."), 100);
        }
    }

    // Start
    init();

</script>
</body>
</html>